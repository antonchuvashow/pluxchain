# Pluxchain: Простая Учебная Блокчейн-Платформа

Pluxchain — это реализация простого блокчейна на Python с использованием FastAPI. Этот проект создан в образовательных целях, чтобы продемонстрировать ключевые концепции, лежащие в основе криптовалют и распределенных систем.

Он включает в себя базовые функции, такие как создание транзакций, майнинг блоков, механизм консенсуса для синхронизации между несколькими узлами (нодами) и HTTP API для взаимодействия.

## 1. Ключевые Концепции

Чтобы понять, как работает Pluxchain, важно ознакомиться с основными терминами.

### Транзакции
Транзакция — это запись о переводе ценности (в нашем случае, условных единиц) от одного адреса к другому.

- **Содержание:** Каждая транзакция содержит адрес отправителя, адрес получателя, сумму и временную метку.
- **Хранение:** Когда пользователь создает транзакцию через API, она не сразу попадает в блокчейн. Сначала она помещается в "пул" или "мемпул" (mempool) — список ожидающих транзакций на узле.
- **Подпись:** В реальных системах транзакция подписывается приватным ключом отправителя для подтверждения владения средствами. Наша модель `SignedTransaction` предусматривает это, хотя текущая реализация валидации подписи упрощена.

### Блоки
Блок — это структура данных, которая содержит группу транзакций и служебную информацию. Блоки — это "страницы" в книге учета блокчейна.

- **Содержание:**
  - **Транзакции:** Список транзакций, включенных в блок.
  - **Заголовок (Header):** Важнейшая часть блока, содержащая:
    - `previous_hash`: Хеш предыдущего блока, что и связывает блоки в цепь.
    - `merkle_root`: Хеш-сумма всех транзакций в блоке. Это позволяет быстро проверить целостность транзакций.
    - `timestamp`: Время создания блока.
    - `nonce`: "Одноразовый номер", который майнеры подбирают в процессе работы.
    - `difficulty`: Сложность майнинга.
- **Майнинг (Proof-of-Work):** Процесс создания нового блока. Майнеры многократно пересчитывают хеш заголовка блока, изменяя `nonce`, пока не найдут хеш, который удовлетворяет условию сложности (например, начинается с определенного количества нулей). Этот процесс требует вычислительных мощностей и защищает сеть от спама и атак.

### Блокчейн
Блокчейн — это непрерывная, последовательная цепочка блоков, связанных между собой с помощью хешей.

- **Неизменяемость:** Изменить информацию в старом блоке практически невозможно, так как это потребует пересчета хешей всех последующих блоков, что требует огромных вычислительных ресурсов.
- **Генезис-блок:** Самый первый блок в цепочке, у которого нет "предыдущего" блока.

### Полные Узлы (Full Nodes)
Полный узел — это сервер (в нашем случае, запущенное приложение `app.py`), который хранит полную копию всего блокчейна.

- **Функции:**
  1. **Хранение:** Содержат все блоки и транзакции.
  2. **Валидация:** Проверяют каждую новую транзакцию и каждый новый блок на соответствие правилам сети.
  3. **Распространение:** Передают новые транзакции и блоки другим узлам.
  4. **Консенсус:** Участвуют в процессе выбора правильной версии цепочки блоков.
  5. **Майнинг:** Узел, который успешно майнит блок, получает награду за блок и комиссии с транзакций.

### Механизм Консенсуса
Консенсус — это процесс, с помощью которого все узлы сети договариваются о единой, "правильной" версии истории транзакций.

- **Правило "Самой Длинной Цепочки" (Longest Chain Wins):** В Pluxchain, как и в Bitcoin, правильной считается та цепочка блоков, у которой наибольшая длина (т.е. в нее вложено больше всего вычислительной работы).
- **Синхронизация (`/nodes/resolve`):** Когда узел хочет синхронизироваться, он запрашивает информацию у других известных ему узлов.
- **Оптимизация "Headers-First":** Чтобы не скачивать гигабайты данных зря, наш узел сначала запрашивает у соседа только *заголовки* блоков (`/chain/headers`). Это очень маленький объем данных. Он быстро проверяет их валидность и длину. Если цепочка заголовков соседа длиннее и корректna, только тогда наш узел запрашивает полные блоки (`/chain`) и заменяет свою старую цепочку.

## 2. Архитектура Проекта

- **`app.py`**: Основной файл, запускающий FastAPI сервер. Определяет все API-эндпоинты и логику жизненного цикла приложения (инициализация, регистрация в сети).
- **`models/`**: Директория с моделями данных.
  - **`core_models.py`**: Фундаментальная бизнес-логика. Здесь описаны классы `Block`, `Transaction`, `Blockchain` и основная логика консенсуса.
  - **`db_models.py`**: Модели SQLAlchemy для хранения данных в базе (используется SQLite).
  - **`api_models.py`**: Модели Pydantic, которые используются для валидации входящих запросов и форматирования ответов API.
- **`db/`**: Модули для работы с базой данных.
  - **`blockchain_dao.py`**: Data Access Object. Слой абстракции, который инкапсулирует всю логику запросов к базе данных (добавить блок, получить все блоки и т.д.).
- **`config.py`**: Конфигурация проекта, включая настройки сложности, адреса и т.д. Также содержит настройки для криптографической идентичности узла (`node_private_key`, `node_public_key`, `node_blockchain_address`) и сетевого адреса (`my_network_address`).
- **`live_client_simulation.py`**: Скрипт-пример, который имитирует активность клиента в сети: создает кошельки, отправляет транзакции и запускает майнинг.

## 3. Руководство для Разработчиков Клиентов (API)

Вы можете взаимодействовать с узлом Pluxchain через его HTTP API.

### Основной флоу клиента:
1. Создать транзакцию.
2. Подписать ее своим приватным ключом (этот шаг происходит на стороне клиента).
3. Отправить подписанную транзакцию на узел сети.
4. Дождаться, пока транзакция будет включена в блок.

### Примеры эндпоинтов:

#### `POST /transactions`
Отправка новой транзакции в сеть. Тело запроса должно соответствовать модели `SignedTransaction`.

#### `POST /blocks/mine`
Запускает процесс майнинга нового блока на узле. Награда за майнинг всегда начисляется на блокчейн-адрес самого узла, который выполняет майнинг.

#### `GET /chain`
Возвращает всю цепочку блоков (с пагинацией).

#### `GET /chain/headers`
Возвращает только заголовки блоков. Используется для быстрой синхронизации.

#### `GET /balance/{address}`
Возвращает баланс указанного адреса.

#### `GET /transactions/pending`
Показывает список транзакций, ожидающих включения в блок.

#### `GET /node/address`
Возвращает блокчейн-адрес текущего узла. Этот адрес используется для получения наград за майнинг.

> **Практический пример:** Изучите файл `live_client_simulation.py`. Он показывает, как создавать ключи, формировать и отправлять транзакции, а также как взаимодействовать с другими эндпоинтами.

## 4. Интерактивная Документация API (Swagger UI)

FastAPI автоматически генерирует интерактивную документацию для всех API-эндпоинтов. Это лучший способ изучить все доступные маршруты, их параметры, тела запросов и примеры ответов.

**Как получить доступ:**
1. Запустите приложение, как описано в разделе "Как запустить".
2. Откройте в браузере один из следующих URL:
   - **Swagger UI (рекомендуется):** `http://127.0.0.1:8000/docs`
   - **ReDoc:** `http://127.0.0.1:8000/redoc`

На этой странице вы сможете:
- Увидеть полный список всех доступных эндпоинтов.
- Раскрыть каждый эндпоинт, чтобы увидеть детальную информацию о нем.
- Посмотреть, какие параметры (в пути, в запросе) принимает эндпоинт.
- Изучить точную структуру (схему) тела запроса и ответа.
- **Самое главное:** Выполнять тестовые запросы прямо из браузера!

Эта документация всегда актуальна, так как она генерируется напрямую из кода (моделей Pydantic и определений эндпоинтов).

## 5. Как запустить

### Требования
- Python 3.10+
- Установите зависимости: `pip install -r requirements.txt`

### Запуск одного узла

```bash
uvicorn app:app --host 0.0.0.0 --port 8000
```
**Важно:** При первом запуске узел сгенерирует свою криптографическую идентичность (приватный ключ, публичный ключ, блокчейн-адрес). Эти данные будут выведены в лог. **Рекомендуется сохранить их в файле `.env`** (например, `NODE_PRIVATE_KEY="...", NODE_PUBLIC_KEY="..."`), чтобы узел всегда имел одну и ту же идентичность при последующих запусках.

### Запуск локальной сети из двух узлов

Этот проект содержит файлы `env.node1` и `env.node2` для удобного запуска двух узлов, которые будут знать друг о друге.

**Терминал 1 (Узел 1):**
```bash
# Запустите первый узел на порту 8000, используя переменные из .env.node1
uvicorn app:app --host 0.0.0.0 --port 8000 --env-file env.node1
```

**Терминал 2 (Узел 2):**
```bash
# Запустите второй узел на порту 8001, используя переменные из .env.node2
uvicorn app:app --host 0.0.0.0 --port 8001 --env-file env.node2
```

**Пример содержимого `env.node1`:**
```
DATABASE_URL="db/block1.sqlite"
MY_NETWORK_ADDRESS="127.0.0.1:8000"
SEED_NODES='["127.0.0.1:8001"]'
NODE_PRIVATE_KEY="<сгенерированный_приватный_ключ_для_узла_1>"
NODE_PUBLIC_KEY="<сгенерированный_публичный_ключ_для_узла_1>"
```

**Пример содержимого `env.node2`:**
```
DATABASE_URL="db/block2.sqlite"
MY_NETWORK_ADDRESS="127.0.0.1:8001"
SEED_NODES='["127.0.0.1:8000"]'
NODE_PRIVATE_KEY="<сгенерированный_приватный_ключ_для_узла_2>"
NODE_PUBLIC_KEY="<сгенерированный_публичный_ключ_для_узла_2>"
```

Теперь у вас есть два узла. Вы можете отправить транзакцию на один из них, замайнить блок, а затем запустить синхронизацию на другом (`POST /nodes/resolve`), чтобы увидеть, как он скачает себе новую цепочку.
